// Simulating multiple self-adaptive systems in multi-cloud environment
// by Azlan Ismail
// features: 
// a) one coordinator with loop
// b) two planners
// c) two qosObservers
  

smg

// player for the adaptation manager
player am 
adaptPlanner, qosObserver, [enlServ], [disServ]
endplayer

//player for the environment
player env 
anvironment 
endplayer

//to control the turn
const TE=0;
const TP=1;
global t:[TE..TP] init TE;

//====================================================
//player environment
const MIN_LATEN;
const MAX_LATEN;
const MAX_TOTAL_LATEN;
module environment
	rt:[MIN_LATEN..MAX_LATEN] init MIN_LATEN;
	rt_total:[0..MAX_TOTAL_LATEN] init 0;
	
	//how X is defined?
	[] (t=TE) & (sat=false) & (X + rt_total < MAX_TOTAL_LATEN) -> (rt'=X) & (rt_total'= rt_total + X) & (t'=TP);

endmodule

//======================================================
// player am

//check the goal satisfaction
formula goal=(rt < maxRT ? true:false);

module adaptPlanner
	sat : bool init false; 

	//make selection
	[enlServ] (t=TP) & (goal=false) & (s < maxServ) -> (t'=TE);	
	[disServ] (t=TP) & (goal=false) & (s >= maxServ) -> (t'=TE);

	//terminate
	[] (t=TP) & (goal=true) & (sat=false) -> (sat'=true);
endmodule

module qosObserver
	//define the range of servers
	//define the range of response time
	// 

	[enlServ] if server 1 is off -> activate server 1 & update the response time 
	[disServ] if server 1 is on -> deactivate server 1 & update the response time

endmodule

//=============================================
//defining the utility preferences / weights
//the values are provided from external 
const W_U1, W_U2;

//=============================================
//defining the utility functions

//u1 -> response time
formula u1 = (rt>= 0 & rt <= 100 ? 1:
			(rt>= 101 & rt <= 200 ? 1:
			(rt>= 201 & rt <= 500 ? 0.99:
			(rt>= 501 & rt <= 1000 ? 0.90:
			(rt>= 1001 & rt <= 1500 ? 0.75:
			(rt>= 1501 & rt <= 2000 ? 0.50:
			(rt>= 2001 & rt <= 4000 ? 0.25:
			(rt> 4000 ? 0:0))))))));

//u2 -> cost / number of servers
formula u2 = (s=0 ? 1 :
		(s=1 ? 1 :
		(s=2 ? 0.90 : 
		(s=3 ? 0.30 :
		(s=4 ? 0 : 0)))));

//=============================================
//defining the impact (cost/benefits)

//impact for u1
formula um1 = 1:


//==============================================
//Computing the utility
rewards "rU"
	t=TP : quality of utility 1 + quality of utility 2;
endrewards


// Labels
label "done" = s=5 | s=6;