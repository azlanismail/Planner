// optimal planning for self-adaptation
// by Azlan Ismail
  

smg

// player for the adaptation manager
player con 
adaptPlanner, target_system, [refreshServiceType], [refreshAllService], [updateDescription]
endplayer

//player for the environment
player env 
environment 
endplayer

//to control the turn
const TE=0;
const TP=1;
global t:[TE..TP] init TE;

//to limit the adaptation cycle (absorbing state)
global end : bool init false;
global goal : bool init false;


//======================================================
// player controller

//define the threshold
const VIOLATED_RT = 10;
const CUR_PROBE = 0;

// to compute the satisfaction of adaptation
formula cur_stat=(rt_composite<VIOLATED_RT?true:false);

module adaptPlanner
	
	//0 - means service failure
	//1 - service not found
	probe:[0..1] init CUR_PROBE;
	
	//make selection
	
	[refreshServiceType] (t=TP) & (goal=false) & (probe>=0) -> (t'=TE);
	[refreshAllService] (t=TP) & (goal=false) & (probe>=0) -> (t'=TE);	
        [updateDescription] (t=TP) & (goal=false) & (probe=0) -> (t'=TE);
	

	//terminate
	[] (t=TP) & (goal=true) & (end=false) -> (end'=true);
endmodule


const MAXRT = 20;
const INITRT= 0; 

//estimated response time for each service
const RT_S1 = 3; //medical service
const RT_S2 = 2; //drug service
const RT_S3 = 3; //alarm service

//service that needs to be refreshed in the case of refresh only a service type
const SS_CH = 1; 

//to hold the global response time for the composite service
global rt_composite:[0..MAXRT] init INITRT;

//to compute the overall service execution time in the case of refresh all services
formula rt_sall = RT_S1 + RT_S2 + RT_S3;

//to compute a specific service execution time in the case of refresh service type
formula rt_ss = (SS_CH=1?RT_S1:(SS_CH=2?RT_S2:(SS_CH=3?RT_S3:0)));

module target_system
	act1 : bool init false;  // for refreshing specific type of service
	act2 : bool init false;  // for refreshing all services
	act3 : bool init false;  // for updating service description
	
	// REFRESH SPECIFIC TYPE OF SERVICE
	[refreshServiceType] (act1=false) -> 0.5:(act1'=true) & (goal'=cur_stat) & (rt_composite'= rt_ss + rt_delay) + //if success
					     0.5:(act1'=false) & (goal'=cur_stat) & (rt_composite'= rt_delay); //if fails
	
	// REFRESH ALL SERVICE
	[refreshAllService] (act2=false) -> (act2'=true) & (goal'=cur_stat) & (rt_composite'= rt_sall + rt_delay);

	// UPDATE SERVICE DESCRIPTION
	[updateDescription] (act3=false) -> (act3'=true) & (goal'=cur_stat) & (rt_composite'= rt_sall + rt_delay);
endmodule

//====================================================
//player environment
const MIN_DELAY = 0;
const MAX_DELAY = 10;
const CUR_DELAY = 3;
const MAX_TOTAL_DELAY = 500;


module environment
	rt_delay:[MIN_DELAY..MAX_DELAY] init MIN_DELAY;
	rt_delay_total:[0..MAX_TOTAL_DELAY] init 0;
	
	//update the network latency
	[] (t=TE) & (end=false) & (CUR_DELAY + rt_delay_total < MAX_TOTAL_DELAY) -> 
		 (rt_delay'=CUR_DELAY)&(rt_delay_total'= rt_delay_total + CUR_DELAY) & (t'=TP);
	//how to increment the value from time to time? using formula perhaps? or rewards, perhaps?

endmodule

//=============================================
//defining the utility functions


//==============================================
//Computing the utility
//Why I need the reward? to hold the total time?
rewards "time"
	t = TP : rt_composite;
endrewards

label "done" = end = true;