// optimal planning for self-adaptation
// by Azlan Ismail
  

smg

// player for the adaptation manager
player con 
adaptPlanner, target_system, [refreshService], [refreshAllService], [test]
endplayer

//player for the environment
player env 
environment 
endplayer

//to control the turn
const TE=0;
const TP=1;
global t:[TE..TP] init TE;

//to limit the adaptation cycle (absorbing state)
global end : bool init false;
global goal : bool init false;


//======================================================
// player controller

//define the threshold
const VIOLATED_RT = 10;

// to compute the satisfaction of adaptation
formula cur_stat=(rt_wf<VIOLATED_RT?true:false);
const UNCERTAINTY = 1;
module adaptPlanner
	
	//make selection
	[refreshAllService] (t=TP) & (goal=false) & (UNCERTAINTY=1) -> (t'=TE);	
	[refreshService] (t=TP) & (goal=false) & (UNCERTAINTY=1) -> (t'=TE);
        [test] (t=TP) & (goal=false) & (UNCERTAINTY=1) -> (t'=TE);

	//terminate
	[] (t=TP) & (goal=true) & (end=false) -> (end'=true);
endmodule

//set the equation for the response time impact
//not sure if i need cost/benefit formula
//formula enlim_rt=rt - 1000 >=0 ? (rt-1000 <= MAXRT?rt-1000:MAXRT):0;
//const disim_rt = 1000;
const MAXRT = 20;
const INITRT= 0; 
const rt_s1 = 3; //medical service
const rt_s2 = 2; //drug service
const rt_s3 = 3; //alarm service
global rt_wf:[0..MAXRT] init INITRT;
formula rt_ss = rt_s1 + rt_s2 + rt_s3;

const rs = 10;
const ra = 4;
module target_system
	act1 : bool init false;  // for refresh service
	act2 : bool init false;  // for update workflow
	act3 : bool init false;  // for testing
	
	
	// REFRESH SERVICE
	// if it has not been selected and suitable for the problematic condition 
	//			-> select and compute rt and cost and estimate satisfaction
	[refreshService] (act1=false) -> (act1'=true) & (goal'=cur_stat) & (rt_wf'= rs + rt_delay);
	
	// UPDATE WORKFLOW
	// if it has not been selected and suitable for the problematic condition 
	//			-> select and compute rt and cost and estimate satisfaction
	[refreshAllService] (act2=false) -> (act2'=true) & (goal'=cur_stat) & (rt_wf'= ra + rt_delay);

	[test] (act3=false) -> (act3'=true) & (goal'=cur_stat) & (rt_wf'= ra + rt_delay);
endmodule

//====================================================
//player environment
const MIN_DELAY = 0;
const MAX_DELAY = 10;
const CUR_DELAY = 3;
const MAX_TOTAL_DELAY = 500;


module environment
	rt_delay:[MIN_DELAY..MAX_DELAY] init MIN_DELAY;
	rt_delay_total:[0..MAX_TOTAL_DELAY] init 0;
	
	//update the network latency
	[] (t=TE) & (end=false) & (CUR_DELAY + rt_delay_total < MAX_TOTAL_DELAY) -> 
		 (rt_delay'=CUR_DELAY)&(rt_delay_total'= rt_delay_total + CUR_DELAY) & (t'=TP);
	//how to increment the value from time to time? using formula perhaps? or rewards, perhaps?

endmodule

//=============================================
//defining the utility functions


//==============================================
//Computing the utility
//Why I need the reward? to hold the total time?
rewards "time"
	t = TP : rt_wf;
endrewards

label "done" = end = true;