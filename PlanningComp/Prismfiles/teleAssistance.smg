// optimal planning for self-adaptation
// by Azlan Ismail
  

smg

// player for the adaptation manager
player con 
adaptPlanner, target_system, [refreshService], [updateWorkflow]
endplayer

//player for the environment
player env 
environment 
endplayer

//to control the turn
const TE=0;
const TP=1;
global t:[TE..TP] init TE;

//to limit the adaptation cycle
global end : bool init false;
global goal : bool init false;
//====================================================
//player environment
const MIN_DELAY = 0;
const MAX_DELAY = 10;
const CUR_DELAY = 3;
const MAX_TOTAL_DELAY = 500;


module environment
	rt_delay:[MIN_DELAY..MAX_DELAY] init MIN_DELAY;
	rt_delay_total:[0..MAX_TOTAL_DELAY] init 0;
	
	//update the network latency
	[] (t=TE) & (end=false) & (CUR_DELAY + rt_delay_total < MAX_TOTAL_DELAY) -> 
		 (rt_delay'=CUR_DELAY)&(rt_delay_total'= rt_delay_total + CUR_DELAY) & (t'=TP);
	//how to increment the value from time to time? using formula perhaps? or rewards, perhaps?

endmodule

//======================================================
// player controller

//check the goal satisfaction
const THRESHOLD_RT = 5000;

//formula goal=(rt_wf < THRESHOLD_RT ? true:false);
module adaptPlanner
	//task:[MIN_TASK..MAX_TASK] init MIN_TASK;

	//make selection
	[updateWorkflow] (t=TP) & (goal=false) -> (t'=TE);	
	[refreshService] (t=TP) & (goal=false) -> (t'=TE);

	//terminate
	[] (t=TP) & (goal=true) & (end=false) -> (end'=true);
endmodule

//set the equation for the response time impact
//not sure if i need cost/benefit formula
//formula enlim_rt=rt - 1000 >=0 ? (rt-1000 <= MAXRT?rt-1000:MAXRT):0;
//const disim_rt = 1000;
const MAXRT = 1000;
const INITRT= 0; 
const rt_s1 = 10; //medical service
const rt_s2 = 8; //drug service
const rt_s3 = 5; //alarm service
global rt_wf:[0..MAXRT] init INITRT;
formula rt_ss = rt_s1 + rt_s2 + rt_s3;

module target_system
	//not sure what to be computed
	//[refreshService] (goal=false) -> 0.6:(goal'=true) & (rt_wf'= rt_ss + rt_delay) + 0.4:(goal'=false) & (rt_wf'= rt_ss + rt_delay);
	[refreshService] (goal=false) -> (goal'=true) & (rt_wf'= rt_ss + rt_delay);
	//[updateWorkflow] (goal=false) -> 0.6:(goal'=true) & (rt_wf'= rt_ss + rt_delay) + 0.4:(goal'=false) & (rt_wf'= rt_ss + rt_delay);
	[updateWorkflow] (goal=false) -> (goal'=true) & (rt_wf'= rt_ss + rt_delay);
endmodule

//=============================================
//defining the utility functions


//==============================================
//Computing the utility
//Why I need the reward? to hold the total time?
rewards "time"
	goal = true : rt_wf;
endrewards

label "done" = end = true;