// optimal planning for self-adaptation
// by Azlan Ismail
  

smg

// player for the adaptation manager
player con 
adaptPlanner, target_system, [refreshService], [updateWorkflow]
endplayer

//player for the environment
player env 
environment 
endplayer

//to control the turn
const TE=0;
const TP=1;
global t:[TE..TP] init TE;

//to limit the adaptation cycle
global end : bool init false;

//====================================================
//player environment
const MIN_DELAY = 0;
const MAX_DELAY = 10;
const CUR_DELAY = 3;
const MAX_TOTAL_DELAY = 500;

formula 
module environment
	rt_delay:[MIN_DELAY..MAX_DELAY] init MIN_DELAY;
	rt_delay_total:[0..MAX_TOTAL_DELAY] init 0;
	
	//update the network latency
	[] (t=TE) & (end=false) & (CUR_DELAY + rt_delay_total < MAX_TOTAL_DELAY) -> 
		 (rt_delay'=CUR_DELAY)&(rt_delay_total'= rt_delay_total + CUR_DELAY) & (t'=TP);
	//how to increment the value from time to time? using formula perhaps? or rewards, perhaps?

endmodule

//======================================================
// player controller

//check the goal satisfaction
formula goal=(rt < MAXRT ? true:false);
module adaptPlanner
	//task:[MIN_TASK..MAX_TASK] init MIN_TASK;

	//make selection
	[refreshService] (t=TP) & (goal=false) -> (t'=TE);	
	[updateWorkflow] (t=TP) & (goal=false) -> (t'=TE);

	//terminate
	[] (t=TP) & (goal=true) & (end=false) -> (end'=true);
endmodule

//set the equation for the response time impact
//not sure if i need cost/benefit formula
//formula enlim_rt=rt - 1000 >=0 ? (rt-1000 <= MAXRT?rt-1000:MAXRT):0;
//const disim_rt = 1000;
const MAXRT = 1000;
const INITRT= 0; 
formula rt_ss = rt_s1 + rt_s2 + rt_s3;
module target_system
	rt_wf:[0..MAXRT] init INITRT;
	//not sure what is purpose of defining services
	const rt_s1 = 10; //medical service
	const rt_s2 = 8; //drug service
	const rt_s3 = 5; //alarm service
	refresh : bool init false;
	update : bool init false;

	//not sure what to be computed
	[refreshService] (refresh=false) -> (refresh'=true) & (rt_wf'= rt_ss + rt_delay);
	[updateWorkflow] (update=false) -> (update'=true) & (rt_wf'= rt_ss + rt_delay);
endmodule

//=============================================
//defining the utility preferences / weights
//the values are provided from external 
const double W_U1 = 0.6;
const double W_U2 = 0.4;

//=============================================
//defining the utility functions

//u1 -> response time
formula u1 = (rt>= 0 & rt <= 100 ? 1:
			(rt>= 101 & rt <= 200 ? 1:
			(rt>= 201 & rt <= 500 ? 0.99:
			(rt>= 501 & rt <= 1000 ? 0.90:
			(rt>= 1001 & rt <= 1500 ? 0.75:
			(rt>= 1501 & rt <= 2000 ? 0.50:
			(rt>= 2001 & rt <= 4000 ? 0.25:
			(rt> 4000 ? 0:0))))))));

//u2 -> cost / number of servers
formula u2 = (s=0 ? 1 :
		(s=1 ? 1 :
		(s=2 ? 0.90 : 
		(s=3 ? 0.30 :
		(s=4 ? 0 : 0)))));


//==============================================
//Computing the utility
rewards "ru"
	t=TP : u1 * W_U1 + u2 * W_U2;
endrewards


// Labels
label "done" = s=5 | s=6;