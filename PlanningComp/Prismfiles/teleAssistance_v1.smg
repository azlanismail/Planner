// optimal planning for self-adaptation
// by Azlan Ismail
  

smg

// player for the adaptation manager
player con 
controller, target_system, [replaceMedic1], [replaceMedic2], [replaceMedic3],[replaceMedic4], [replaceMedic5], [replaceServiceB]
//service A - medical service
//service B - alarm service
endplayer

//player for the environment
player env 
environment 
endplayer

//to control the turn
const TE=0;
const TP=1;
global t:[TE..TP] init TE;

//to limit the adaptation cycle 
global end : bool init false;	//(absorbing state)
global goal : bool init false;	//adaptation goal

//to hold the global response time for the composite service
//used in two modules
//global rt_composite:[0..MAX_RT] init INIT_RT;

//inputs from the adaptation engine:
//const CUR_PROBE = 1;	//identified probe - is used to decide for the appropriate action
const CUR_PROBE = 0;
const MAX_RT = 26 + MAX_TOTAL_DELAY;	//maximum response time - to limit the goal
const INIT_RT= 0; 	//initial response time

//input from the adaptation engine: (in the case of refresh only a service type)
//const SS_TY = 1; //service that needs to be refreshed
//const SS_TY;

//overall service info
const MAX_SV = 10;

//alarm service info - id
const int SV_ALARM1_ID = 1;
const int SV_ALARM2_ID = 2;
const int SV_ALARM3_ID = 3;

//alarm service info - response time
const int SV_ALARM1_RT = 11; 
const int SV_ALARM2_RT = 9;
const int SV_ALARM3_RT = 3;

//alarm service info - success rate
const double SV_ALARM1_SR = 1 - 0.11; 
const double SV_ALARM2_SR = 1 - 0.04;
const double SV_ALARM3_SR = 1 - 0.18;

//medical service info - id
const int SV_MEDIC1_ID = 4; 
const int SV_MEDIC2_ID = 5;
const int SV_MEDIC3_ID = 6;
const int SV_MEDIC4_ID = 7;
const int SV_MEDIC5_ID = 8;

//medical service info - response time
const int SV_MEDIC1_RT = 22; 
const int SV_MEDIC2_RT = 27;
const int SV_MEDIC3_RT = 31;
const int SV_MEDIC4_RT = 29;
const int SV_MEDIC5_RT = 20;

//medical service info - success rate
const double SV_MEDIC1_SR = 1 - 0.12; 
const double SV_MEDIC2_SR = 1 - 0.07;
const double SV_MEDIC3_SR = 1 - 0.18;
const double SV_MEDIC4_SR = 1 - 0.25;
const double SV_MEDIC5_SR = 1 - 0.05;

//drug service info
const int SV_DRUG_ID = 9;
const int SV_DRUG_RT = 1;
const double SV_DRUG_SR = 1 - 0.01;

//composite service
const int CSV_ID = 10; 

//failed service
const int SV_FAIL_TY = 0; //set to medical service
const int SV_FAIL_ID = 5; //refer to specific medical service

//======================================================
// player controller

module controller
	//0 - means service failure
	//1 - service not found
	probe:[0..1] init CUR_PROBE;
	
	//make selection
	[replaceServiceA] (t=TP) & (goal=false) & (probe>=0) & (SV_FAIL_TY=0) -> (t'=TE);	
	[replaceServiceB] (t=TP) & (goal=false) & (probe>=0) & (SV_FAIL_TY=1) -> (t'=TE);
	
	//terminate
	[] (t=TP) & (goal=true) & (end=false) -> (end'=true);
endmodule


module target_system
	sel_sv:[0..MAX_SV] init SV_FAIL_ID;
	
	//for medical service
	[replaceMedic1] (SV_FAIL_ID = SV_MEDIC1_ID) -> 
			   ref1:(sel_sv'=SV_MEDIC2_ID) & (goal'=sat) +
			   ref2:(sel_sv'=SV_MEDIC3_ID) & (goal'=sat) +
                           ref3:(sel_sv'=SV_MEDIC4_ID) & (goal'=sat) +
                           ref4:(sel_sv'=SV_MEDIC5_ID) & (goal'=sat);

	[replaceMedic2] (SV_FAIL_ID = SV_MEDIC2_ID) -> 
			   ref1:(sel_sv'=SV_MEDIC1_ID) & (goal'=sat) +
			   ref2:(sel_sv'=SV_MEDIC3_ID) & (goal'=sat) +
                           ref3:(sel_sv'=SV_MEDIC4_ID) & (goal'=sat) +
			   ref4:(sel_sv'=SV_MEDIC5_ID) & (goal'=sat);
			//((max_medic_sr-SV_MEDIC5_SR)/dis_medic_sr):(sel_sv'=SV_MEDIC5_ID) & (goal'=sat);

	[replaceMedic3] (SV_FAIL_ID = SV_MEDIC3_ID) -> 
			   ref1:(sel_sv'=SV_MEDIC1_ID) & (goal'=sat) +
			   ref2:(sel_sv'=SV_MEDIC2_ID) & (goal'=sat) +
                           ref3:(sel_sv'=SV_MEDIC4_ID) & (goal'=sat) +
                           ref4:(sel_sv'=SV_MEDIC5_ID) & (goal'=sat);

	[replaceMedic4] (SV_FAIL_ID = SV_MEDIC4_ID) -> 
			   ref1:(sel_sv'=SV_MEDIC1_ID) & (goal'=sat) +
			   ref2:(sel_sv'=SV_MEDIC2_ID) & (goal'=sat) +
                           ref3:(sel_sv'=SV_MEDIC3_ID) & (goal'=sat) +
                           ref4:(sel_sv'=SV_MEDIC5_ID) & (goal'=sat);

	[replaceMedic5] (SV_FAIL_ID = SV_MEDIC5_ID) -> 
			   ref1:(sel_sv'=SV_MEDIC1_ID) & (goal'=sat) +
			   ref2:(sel_sv'=SV_MEDIC2_ID) & (goal'=sat) +
                           ref3:(sel_sv'=SV_MEDIC3_ID) & (goal'=sat) +
                           ref4:(sel_sv'=SV_MEDIC4_ID) & (goal'=sat);

	//for alarm service
	[replaceServiceB] (SV_FAIL_ID = SV_ALARM1_ID) -> 
			   ref_alarm1:(sel_sv'=SV_ALARM2_ID) & (goal'=sat) +
			   ref_alarm2:(sel_sv'=SV_ALARM3_ID) & (goal'=sat);

	[replaceServiceB] (SV_FAIL_ID = SV_ALARM2_ID) -> 
			   ref_alarm1:(sel_sv'=SV_ALARM1_ID) & (goal'=sat) +
			   ref_alarm2:(sel_sv'=SV_ALARM3_ID) & (goal'=sat);

	[replaceServiceB] (SV_FAIL_ID = SV_ALARM3_ID) -> 
			   ref_alarm1:(sel_sv'=SV_ALARM1_ID) & (goal'=sat) +
			   ref_alarm2:(sel_sv'=SV_ALARM2_ID) & (goal'=sat);
endmodule

//====================================================
//player environment
const MIN_DELAY = 0;
const MAX_DELAY = 3;
const CUR_DELAY = 0;
const MAX_TOTAL_DELAY = 10;


module environment
	rt_delay:[MIN_DELAY..MAX_DELAY] init MIN_DELAY;
	rt_delay_total:[0..MAX_TOTAL_DELAY] init 0;
	
	//update the network latency
	[] (t=TE) & (end=false) & (CUR_DELAY + rt_delay_total < MAX_TOTAL_DELAY) -> 
		 (rt_delay'=CUR_DELAY)&(rt_delay_total'= rt_delay_total + CUR_DELAY) & (t'=TP);
endmodule

//=============================================
//defining the formulas

//to normalize the success rate of alarm service
formula max_alarm_sr = max(SV_ALARM1_SR, SV_ALARM2_SR, SV_ALARM3_SR);
formula min_alarm_sr = min(SV_ALARM1_SR, SV_ALARM2_SR, SV_ALARM3_SR);
formula dis_alarm_sr = max_alarm_sr - min_alarm_sr;

//to normalize the success rate of medic service
formula max_medic_sr = max(SV_MEDIC1_SR, SV_MEDIC2_SR, SV_MEDIC3_SR, SV_MEDIC4_SR, SV_MEDIC5_SR);
formula min_medic_sr = min(SV_MEDIC1_SR, SV_MEDIC2_SR, SV_MEDIC3_SR, SV_MEDIC4_SR, SV_MEDIC5_SR);
formula dis_medic_sr = max_medic_sr - min_medic_sr;

//to compute the overall service execution time 
formula sv_rt = ( sel_sv = SV_ALARM1_ID ? SV_ALARM1_RT + rt_delay :
		( sel_sv = SV_ALARM2_ID ? SV_ALARM2_RT + rt_delay :
		( sel_sv = SV_ALARM3_ID ? SV_ALARM3_RT + rt_delay :
		( sel_sv = SV_MEDIC1_ID ? SV_MEDIC1_RT + rt_delay :
		( sel_sv = SV_MEDIC2_ID ? SV_MEDIC2_RT + rt_delay :
		( sel_sv = SV_MEDIC3_ID ? SV_MEDIC3_RT + rt_delay :
		( sel_sv = SV_MEDIC4_ID ? SV_MEDIC4_RT + rt_delay :
		( sel_sv = SV_MEDIC5_ID ? SV_MEDIC5_RT + rt_delay : 0 ))))))));

//to compute the satisfaction of adaptation goal
formula sat = (sv_rt<MAX_RT?true:false);

formula ref1 = 0.2;
formula ref2 = 0.3;
formula ref3 = 0.2;
formula ref4 = 0.3;


formula ref_alarm1 = 0.7;
formula ref_alarm2 = 0.3;
//to compute a specific service execution time in the case of refresh service type
//formula rt_ss = (SS_TY=1?RT_S1:(SS_TY=2?RT_S2:(SS_TY=3?RT_S3:0)));

//==============================================
//Computing the utility
//Why I need the reward? to hold the total time?
rewards "time"
	t = TP : sv_rt;
endrewards

label "done" = end = true;